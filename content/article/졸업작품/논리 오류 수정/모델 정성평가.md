---
date: '2025-07-25T14:15:48+09:00'
draft: false
title: '모델 정성평가'
weight: 4
---

이 글에서는 학습이 완료된 모델이 실제 알고리즘 문제의 오답 코드를 얼마나 잘 수정하는지를 예시 중심으로 살펴본다.  
각 예시는 문제 설명, 오답 코드, 모델이 수정한 코드로 구성되어 있으며, **논리적 오류를 얼마나 정확하게 고쳤는지**를 확인할 수 있다.

## 조건문 비교 오류

### 문제 설명

타카하시는 자판기에서 음료수를 살 때 나는 소리를 좋아합니다.  
그 소리는 매번 A엔을 쓸 때 들을 수 있습니다.  
타카하시는 B엔을 가지고 있으며, 그 돈으로 할 수 있는 한 여러 번, 하지만 그때 만족할 만큼 최대 C번까지 들을 수 있습니다.  
그는 그 소리를 몇 번이나 듣게 될까요?

### 오답 코드

```python
a, b, c = map(int, input().split())
sound = 0
for i in range(c):
    b -= a
    if a < 0:  # <- 틀린 조건
        break
    else:
        sound += 1
print(sound)
```

### 모델 수정 결과

```python
a, b, c = map(int, input().split())
sound = 0
for i in range(c):
    b -= a
    if b < 0:  # <- 올바르게 수정됨
        break
    else:
        sound += 1
print(sound)
```

### 평가

* `if a < 0:` → `if b < 0:`으로 조건을 바꾸는 것이 핵심
* **논리 흐름 파악이 필요한 조건문 오류를 정확히 수정함**


## 연산 순서 오류 (출력 위치)

### 문제 설명

연못에 조류의 총 중량을 x\_i라고 하겠습니다.
i ≥ 2000인 경우 다음 식이 적용됩니다:

```
x_{i+1} = r * x_i - D
```

r, D, x\_{2000}이 주어질 때, x\_{2001}부터 x\_{2010}까지 계산하여 출력합니다.


### 오답 코드

```python
a, b, c = map(int, input().split())
for i in range(10):
    print(c)  # <- 출력이 먼저 되어버림
    c = a * c - b
```

### 모델 수정 결과

```python
a, b, c = map(int, input().split())
for i in range(10):
    c = a * c - b
    print(c)  # <- 위치가 수정됨
```

### 평가

* 연산 순서에 따른 출력 위치 오류를 명확히 수정
* **출력 타이밍에 민감한 문제에서 모델이 순서를 인식했음을 보여줌**


## 연산자 오류 (정수 나눗셈)

### 문제 설명

다카하시는 무한한 구구단 위에 서 있습니다.
각 정사각형 (i, j)에는 i × j가 적혀 있으며,
(1,1)에서 시작해 (i+1, j) 또는 (i, j+1)로만 이동할 수 있습니다.
정수 N이 주어질 때, N을 포함하는 칸까지 이동하는 최소 이동 횟수를 구하세요.


### 오답 코드

```python
import math

var0 = int(input())
var1 = 10 ** 15

for k in range(1, int(math.sqrt(var0)) + 1):
    if var0 % k > 0:
        continue
    var1 = min(var1, k + var0 / k - 2)  # <- / 사용
print(var1)
```

### 모델 수정 결과

```python
import math

var0 = int(input())
var1 = 10 ** 15

for k in range(1, int(math.sqrt(var0)) + 1):
    if var0 % k > 0:
        continue
    var1 = min(var1, k + var0 // k - 2)  # <- 정수 나눗셈으로 수정
print(var1)
```

### 평가

* `/` → `//`로 수정하여 **정수 계산에 필요한 정확한 연산자**를 반영
* **입력의 특성과 타입을 고려한 수식 오류 수정**

## 모델의 제한점

학습된 모델이 일정 수준의 논리 오류를 수정할 수 있었지만, 실제 사용 환경에서 다음과 같은 제한점이 확인되었다:

1. 다중 오류에 대한 취약성

    - 코드에 **두 개 이상의 논리 오류**가 동시에 존재할 경우, 하나만 고치고 나머지는 놓치는 경우가 많았다.
    - 모델이 순차적 디버깅 능력을 가지지 않기 때문에 **단일 수정 중심의 오류 대응**에 머무는 경향이 있다.

2. 코드 추상화 품질 의존성

    - 문제 설명과 코드 간의 관계를 제대로 학습하려면, 데이터셋의 **전처리 품질**이 매우 중요하다.

    - 문제 요약, 변수 정리, 토크나이징 등의 **입력 정제 과정이 성능에 큰 영향**을 준다.

3. 복잡한 알고리즘 문제에 대한 한계

    - 조건이 많고 상태 변화가 복잡한 알고리즘 문제에 대해서는 **성능이 크게 저하**되었다.


## 전체 평가 요약

| 예시 | 오류 유형       | 수정 성공 여부 | 비고              |
| -- |-- |-- | --- |
| 1  | 조건문 비교 오류   | ✅        | 문제 맥락에 맞는 조건 식별 |
| 2  | 연산 순서 오류    | ✅        | 출력 위치 정확히 조정    |
| 3  | 수식 내 연산자 오류 | ✅        | 연산자 의미 파악 성공    |

모델은 세 가지 예시 모두에서 **문제의 조건과 코드 흐름을 일치시키는 수정**을 성공적으로 수행하였다.
이는 단순한 패턴 치환이 아닌, **문맥 기반 코드 수정 능력**이 일정 수준 이상임을 보여준다.

## 회고

이게 정말 되는 걸까 싶은 생각도 들었지만 여러가지 케이스들을 테스트해보면서 정리해보니 완전히 잘못만들지는 않았다는 생각이 들었다.